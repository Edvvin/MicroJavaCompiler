package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, LBRACE, RBRACE, LSQR, RSQR, SEMI;
terminal LPAREN, RPAREN, CONST, COMMA, PRINT;
terminal RETURN, VOID, NEW, CONTINUE, WHILE ;
terminal PLUS, MINUS, ASTK, DIV, MOD, AND, OR;
terminal INC, DEC, EQUAL, GT, GET, LT, LET, EQEQ, NEQ;
terminal READ, BREAK, DO, QSTMK, COLON, IF, ELSE;
terminal EXTENDS, DOT, SWITCH, ENUM, CLASS, CASE ;
terminal Integer NUMBER ;
terminal String IDENT ;
terminal Character CHAR ;
terminal String BOOL ;

nonterminal MethodDeclList, VarDecl, FormalParams ;
nonterminal FormalParamList, FormalParamDecl, ActualPars, ActualParamList ; 
nonterminal StatementList, CondFact, CondTerm, Statement ;
nonterminal DesignatorStatement, Addop, Mulop, Relop ;
nonterminal GlobDeclList, Decl, CnstDecl, CnstAsgnList ; 
nonterminal VarAsgnList, VarAsgnOne, MethodType ;
nonterminal ActualParsStart, CnstAsgn, DoPartOfWhile ;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, ProgName, Designator, MethodDecl, MethodTypeName ; 
nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition, Type, Term, SumExpr, Expr, Expr1, Factor, VarDeclList ; 

precedence left ELSE ;

Program ::= (AstProgram) PROG ProgName:progName GlobDeclList:decls LBRACE MethodDeclList:methods RBRACE ;

ProgName ::= (AstProgName) IDENT:prog ;

GlobDeclList ::= (AstGlobDeclL) GlobDeclList Decl
			|
			(AstNoGlobDecl) /* epsilon */
			;

Decl ::= (AstGlobCnstDecl) CnstDecl
		|
		(AstGlobVarDecl) VarDecl
		;
		
CnstDecl ::= (AstCnstDecl) CONST Type CnstAsgnList;

CnstAsgnList ::= (AstCnstAsgnL) CnstAsgn COMMA CnstAsgnList
				|
				(AstCnstAsgnOne) CnstAsgn SEMI
				|
				(AstCnstAsgnCommaErr) error:e COMMA
				{: parser.report_error("Syntax Error: Bad declaration of global constant in line " + eleft + ". Recovered until ','", null); :}
				|
				(AstCnstAsgnSemiErr) error:e SEMI
				{: parser.report_error("Syntax Error: Bad declaration of global constant in line " + eleft + ". Recovered until ';'", null); :}
				;

CnstAsgn ::= (AstCnstAsgnInt) IDENT:cnstName EQUAL	NUMBER:value 
			|
			(AstCnstAsgnChar) IDENT:cnstName EQUAL	CHAR:value 
			|
			(AstCnstAsgnBool) IDENT:cnstName EQUAL	BOOL:value 
			;

VarDeclList ::= (AstVarDeclL) VarDeclList VarDecl
				|
				(AstNoVarDecl) /* epsilon */
				;

VarDecl ::= (AstVarDecl) Type:varType VarAsgnList ;

VarAsgnList ::= (AstVarAsgnL) VarAsgnOne COMMA VarAsgnList
					|
					(AstVarAsgnSemi) VarAsgnOne SEMI
					|
					(AstVarAsgnCommaErr) error:e COMMA
					{: parser.report_error("Syntax Error: Bad declaration of global variable in line " + eleft + ". Recovered until ','", null); :}
					|
					(AstVarAsgnSemiErr) error:e SEMI
					{: parser.report_error("Syntax Error: Bad declaration of global variable in line " + eleft + ". Recovered until ';'", null); :}
					;
				
VarAsgnOne ::= (AstVarAsgn) IDENT:varName
				|
				(AstVarArrAsgn) IDENT:varName LSQR RSQR
					;

Type ::= (AstType) IDENT:typeName 
;

MethodDeclList ::= (AstMethDeclL) MethodDeclList MethodDecl
					|
					(AstNoMethodDecl)/* epsilon */
					;

MethodDecl ::= (AstMethDecl) MethodTypeName
			   FormalParams VarDeclList LBRACE StatementList RBRACE 
			   ;

MethodTypeName ::= (AstMethTypeName) Type:retType IDENT:methName
					|
					(AstMethVoidName) VOID IDENT:methName
					;

FormalParams ::= (AstFormalParams) LPAREN FormalParamList RPAREN
				|
				(AstFormalParamsErr) LPAREN error:e RPAREN
				{: parser.report_error("Syntax Error: Formal parameters invalid in line " + eleft + " Recovered until ')'", null ); :}
				;

FormalParamList ::= (AstFormalParamL) FormalParamDecl COMMA FormalParamList
					|
					(AstFormalParamListErr) error:e COMMA
					{: parser.report_error("Syntax Error: Formal parameters invalid in line " + eleft + " Recovered until ','", null ); :}
					|
					(AstFormalParamOne) FormalParamDecl
					|
					(AstNoFormalParams) /* epsilon */
					;
					
FormalParamDecl ::= (AstFormalParamDecl) Type IDENT:paramName
					|
					(AstFormalParamArrDecl) Type IDENT:paramName LSQR RSQR 
					;
					
StatementList ::= (AstStatementL) StatementList Statement 
					|
				  (AstNoStmt) /* epsilon */
				  ;
				  
DesignatorStatement ::= (AstEqualStmt) Designator EQUAL Expr 
					|
					(AstIncStmt) Designator INC
					|
					(AstDecStmt) Designator DEC
					|
					(AstFuncCallStmt) Designator LPAREN ActualPars RPAREN
;

Statement ::= (AstDesigStmt) DesignatorStatement:des SEMI 
			  |
			  (AstErrAssignment) Designator EQUAL error:e SEMI
			  {: parser.report_error("Syntax Error: Bad assignment of designator in line " + eleft + ". Recovered until ';'", null ); :}
			  |
			  (AstPrintStmt) PRINT LPAREN Expr RPAREN SEMI 
			  |
			  (AstPrintStmtParam) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI 
			  |
			  (AstReadStmt) READ LPAREN Designator RPAREN SEMI 
			  |
			  (AstBreakStmt) BREAK SEMI
			  | 
			  (AstContinueStmt) CONTINUE SEMI
			  | 
			  (AstReturnExpr) RETURN Expr:t SEMI
			  |
			  (AstReturnNoExpr) RETURN SEMI
			  | 
			  (AstUnmatchedIf) IF LPAREN Condition RPAREN Statement
			  |
			  (AstMatchedIf) IF LPAREN Condition RPAREN Statement ELSE Statement
			  |
			  (AstDoWhile) DoPartOfWhile Statement WHILE LPAREN Condition RPAREN SEMI
			  |
			  (AstStmtL) LBRACE StatementList RBRACE
			  ;
			  
DoPartOfWhile ::= (AstDoPart) DO ;
			  
Expr ::= (AstTerExpr) Expr1 QSTMK Expr1 COLON Expr1
		|
		(AstNotTerExpr) Expr1
		;
		
Expr1 ::= (AstNegExpr) MINUS SumExpr
		|
		(AstPosExpr) SumExpr
		;


SumExpr ::= (AstAddExpr) SumExpr:se Addop Term:t
		 |
		 (AstTermExpr) Term:t
		 ;

Term ::= (AstTermOne) Factor:t 
		|
		(AstTermL) Term Mulop:op Factor:t
;

Factor ::= (AstFactNum) NUMBER
			|
			(AstFactChar) CHAR
			|
			(AstFactBool) BOOL
			|
			(AstBraceExpr) LPAREN Expr:e RPAREN 
			|
		   (AstDesigFact) Designator:d
		    |
		   (AstFuncCallFact) Designator:func LPAREN ActualPars RPAREN
		    |
		   (AstNewArray) NEW Type:t LSQR Expr:e RSQR
		   ;

ActualPars ::= (AstActualParams) ActualParsStart ActualParamList 
				| 
			   (AstNoActualParam) /* epsilon */ 
			   ;
			   
ActualParsStart ::= (AstStartActualParams) /* epsilon */ ;
			   
ActualParamList ::= (AstActualParamsL) Expr COMMA ActualParamList
					|
					(AstActualParamsOne) Expr
					;
					
Condition ::= (AstConditionOne) CondTerm
			|
			(AstConditionL) CondTerm OR Condition
			;

CondTerm ::= (AstCondTermOne) CondFact
			|
			(AstCondTermL) CondFact AND CondTerm
			;

CondFact ::= (AstCondFact) Expr:e1 Relop Expr:e2
			;

Designator ::= (AstDesig) IDENT:name 
				|
				(AstIndexDesig) Designator LSQR Expr RSQR 
;

Addop ::= (AstAddop) PLUS 
		| 
		(AstSubop) MINUS
;

Mulop ::= (AstMulop) ASTK 
		| 
		(AstDivop) DIV 
		| 
		(AstModop) MOD
;

Relop ::= (AstEqop) EQEQ
			|
			(AstNeop) NEQ
			|
			(AstGtop) GT
			|
			(AstGetop) GET
			|
			(AstLtop) LT
			|
			(AstLetop) LET
			;