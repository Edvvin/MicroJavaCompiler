package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, LBRACE, RBRACE, LSQR, RSQR, SEMI, LPAREN, RPAREN, CONST, COMMA, PRINT, RETURN, VOID, NEW, CONTINUE, WHILE ;
terminal PLUS, MINUS, ASTK, DIV, MOD, AND, OR, INC, DEC, EQUAL, GT, GET, LT, LET, EQEQ, NEQ, READ, BREAK, DO, QSTMK, COLON;
terminal EXTENDS, DOT, SWITCH, ENUM, CLASS, CASE ;
terminal Integer NUMBER ;
terminal String IDENT ;
terminal String CHAR ;
terminal Boolean BOOL ;
terminal IF, ELSE ;

nonterminal MethodDeclList, VarDecl, FormalParams ;
nonterminal FormalParamList, FormalParamDecl, ActualPars, ActualParamList, Relop; 
nonterminal StatementList, Condition, CondFact, CondTerm, SumExpr, Statement, DesignatorStatement, Addop, Mulop ;
nonterminal GlobDeclList, Decl, CnstDecl, CnstAsgnList, CnstValue, VarAsgnList, VarAsgnOne, MethodType ;

nonterminal rs.etf.pp1.symboltable.concepts.Obj Program, Designator, MethodDecl, MethodTypeName ; 
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Expr, Expr1, Factor, VarDeclList ; 

precedence left ELSE ;

Program ::= (Program) PROG IDENT:progName GlobDeclList:decls LBRACE MethodDeclList:methods RBRACE 
;

GlobDeclList ::= (GlobDeclList) GlobDeclList Decl
			|
			(NoGlobDecl) /* epsilon */
			;

Decl ::= (GlobCnstDecl) CnstDecl
		|
		(GlobVarDecl) VarDecl
		;
		
CnstDecl ::= (CnstDecl) CONST Type CnstAsgnList;

CnstAsgnList ::= (CnstAsgn) IDENT EQUAL CnstValue COMMA CnstAsgnList
				|
				(CnstAsgnLast) IDENT EQUAL CnstValue SEMI
				|
				(CnstAsgnCommaErr) error COMMA
				{: parser.report_error("Syntax Error: Bad declaration of global constant in line " + lleft.toString() + ". Recovered until ','", null); :}
				|
				(CnstAsgnSemiErr) error SEMI
				{: parser.report_error("Syntax Error: Bad declaration of global constant in line " + lleft.toString() + ". Recovered until ';'", null); :}
				;

CnstValue ::= (CnstNum) NUMBER
			|
			(CnstChr) CHAR
			|
			(CnstBool) BOOL
			;

VarDeclList ::= (VarDeclList) VarDeclList VarDecl
				|
				(NoVarDecl) /* epsilon */
				;

VarDecl ::= (VarDecl) Type:varType IDENT:varName SEMI 
				|
				(VarArrDecl) Type:varType LSQR RSQR IDENT:varName SEMI
				;

VarAsgnList ::= (VarAsgn) VarAsgnOne COMMA VarAsgnList
					|
					(VarAsgnLast) VarAsgnOne SEMI
					|
					(VarAsgnCommaErr) error COMMA
					{: parser.report_error("Syntax Error: Bad declaration of global variable in line " + lleft.toString() + ". Recovered until ','", null); :}
					|
					(VarAsgnSemiErr) error SEMI
					{: parser.report_error("Syntax Error: Bad declaration of global variable in line " + lleft.toString() + ". Recovered until ';'", null); :}
					;
				
VarAsgnOne ::= (VarAsgnOne) IDENT
					|
					(VarArrAsgnOne) IDENT LSQR RSQR
					;

Type ::= (Type) IDENT:typeName 
;

MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
					|
					(NoMethodDecl)/* epsilon */
					;

MethodDecl ::= (MethodDecl) MethodTypeName
			   FormalParams VarDeclList LBRACE StatementList RBRACE 
			   ;

MethodTypeName ::= (MethodTypeName) MethodType:retType IDENT:methName
;

MethodType ::= (MethodVoid) VOID
				|
				(MethodType) Type
				;

FormalParams ::= (FormalParams) LPAREN FormalParamList RPAREN
				|
				(FormalParamsErr) LPAREN error RPAREN
				{: parser.report_error("Syntax Error: Formal parameters invalid in line " + lleft.toString() + " Recovered until ')'", null ); :}
				;

FormalParamList ::= (FormalParamList) FormalParamDecl COMMA FormalParamList
					|
					(FormalParamListErr) error COMMA
					{: parser.report_error("Syntax Error: Formal parameters invalid in line " + lleft.toString() + " Recovered until ','", null ); :}
					|
					(FormalParamLast) FormalParamDecl
					|
					(NoFormalParams) /* epsilon */
					;
					
FormalParamDecl ::= (FormalParamDecl) Type IDENT 
					|
					(FormalParamArrDecl) Type IDENT LSQR RSQR 
					;
					
StatementList ::= (Statements) StatementList Statement 
					|
				  (NoStmt) /* epsilon */
				  ;
				  
DesignatorStatement ::= (EqualStmt) Designator EQUAL Expr 
					|
					(IncStmt) Designator INC
					|
					(DecStmt) Designator DEC
					|
					(FuncCallStmt) Designator LPAREN ActualPars RPAREN
;

Statement ::= (DesigStmt) DesignatorStatement:des SEMI 
			  |
			  (ErrAssignment) Designator EQUAL error SEMI
			  {: parser.report_error("Syntax Error: Bad assignment of designator in line " + lleft.toString() + ". Recovered until ';'", null ); :}
			  |
			  (PrintStmt) PRINT LPAREN Expr RPAREN SEMI 
			  |
			  (PrintStmtParam) PRINT LPAREN Expr COMMA NUMBER RPAREN SEMI 
			  |
			  (ReadStmt) READ LPAREN Designator RPAREN SEMI 
			  |
			  (BreakStmt) BREAK SEMI
			  | 
			  (ContinueStmt) CONTINUE SEMI
			  | 
			  (ReturnExpr) RETURN Expr:t SEMI
			  |
			  (ReturnNoExpr) RETURN SEMI
			  | 
			  (UnmatchedIf) IF LPAREN Expr RPAREN Statement
			  |
			  (MatchedIf) IF LPAREN Expr RPAREN Statement ELSE Statement
			  |
			  (IfErr) IF LPAREN error RPAREN
			  {: parser.report_error("Syntax Error: Bad condition in if statement in line " + lleft.toString() + ". Recovered until ')'", null ); :}
			  |
			  (DoWhile) DO Statement WHILE LPAREN Condition RPAREN SEMI
			  |
			  (StmtList) LBRACE StatementList RBRACE
			  ;
			  
Expr ::= (TerExpr) Expr1 QSTMK Expr1 COLON Expr1
		|
		(Expr) Expr1
		;
		
Expr1 ::= (NegExpr) MINUS SumExpr
		|
		(PosExpr) SumExpr
		;


SumExpr ::= (AddExpr) Term:t Addop SumExpr:se 
		 |
		 (TermExpr) Term:t
		 ;

Term ::= (Term) Factor:t 
		|
		(Terms) Term Mulop:op Factor:t
;

Factor ::= (NumCnst) NUMBER
			|
			(CharCnst) CHAR
			|
			(BoolCnst) BOOL
			|
			(BraceExpr) LPAREN Expr:e RPAREN 
			|
		   (Var) Designator:d
		    |
		   (FuncCallFact) Designator:func LPAREN ActualPars RPAREN
		    |
		   (NewObj) NEW Type:t LSQR Expr:e RSQR
		   ;

ActualPars ::= (ActualParams) ActualParamList 
				| 
			   (NoActuals) /* epsilon */ 
			   ;
			   
ActualParamList ::= (ActualParamsList) ActualParamList COMMA Expr
					|
					(ActualParamsLast) Expr
					;
					
Condition ::= (Condition) CondTerm
			|
			(ConditionList) CondTerm OR Condition
			;

CondTerm ::= (CondTerm)	CondFact
			|
			(CondTermList) CondFact AND CondTerm
			;

CondFact ::= (CondFact) Expr
			|
			(CondFactList) Expr Relop Expr
			;

Designator ::= (Designator) IDENT:name 
				|
				(IndexDesig) IDENT:name LSQR Expr RSQR 
;

Addop ::= (Addop) PLUS 
		| 
		(Subop) MINUS
;

Mulop ::= (Mulop) ASTK 
		| 
		(Divop) DIV 
		| 
		(Modop) MOD
;

Relop ::= (Eqop) EQEQ
			|
			(Gtop) GT
			|
			(Getop) GET
			|
			(Ltop) LT
			|
			(Letop) LET
			;